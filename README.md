# algorithm
#### 说明：1. 一些题目的详细描述或算法思路以代码注释呈现，可以进入题目里面查看；
### [剑指offer](https://github.com/fupengfei058/algorithm/tree/master/%E5%89%91%E6%8C%87offer)
1. 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
2. 请实现一个函数，将一个字符串中的空格替换成“%20”。
3. 输入一个链表，从尾到头打印链表每个节点的值。
4. 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
5. 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
6. 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
7. 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n<=39
8. 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
9. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法
10. 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法
11. 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
12. 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
13. 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
14. 输入一个链表，输出该链表中倒数第k个结点。
15. 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
16. 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
17. 操作给定的二叉树，将其变换为源二叉树的镜像。
18. 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字
19. 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。
20. 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
21. 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
22. 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
23. 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
24. 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
25. 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。
26. 输入一个字符串,按字典序打印出该字符串中字符的所有排列。
27. 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
28. 输入n个整数，找出其中最小的K个数。
29. 连续子数组最大和
30. 求出1 ~ 13的整数中1出现的次数,并算出100 ~ 1300的整数中1出现的次数
31. 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
32. 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
33. 在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置
34. 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
35. 输入两个链表，找出它们的第一个公共结点。
36. 统计一个数字在排序数组中出现的次数。
37. 输入一棵二叉树，求该树的深度。
38. 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
39. 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
40. 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
41. 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
42. 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。
43. 翻转单词顺序，例如：输入“I am a student.”，输出“student. a am I”。
44. 一幅扑克牌，任意抽取5张，判断是5张牌是否是顺子。“顺子”指的是五张牌的紧紧相连的五张牌，如A,2,3,4,5或者8,9,10,J,Q，其中，大小王可以代表任意你想代表的牌。设计一个程序判断随机抽取的5张牌是否是顺子。
45. 0,1，...n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字，求出这个圆圈里剩下的最后一个数字。
46. 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
47. 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、* 、/四则运算符号。
48. 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回0。
49. 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
50. 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i] = A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]。不能使用除法。
51. 请实现一个函数用来匹配包括' . '和' * '的正则表达式。模式中的字符' . '表示任意一个字符，而' * '表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。
52. 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
53. 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。如果当前字符流没有存在出现一次的字符，返回#字符。
54. 一个链表中包含环，请找出该链表的环的入口结点。
55. 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5。
56. 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
57. 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
58. 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
59. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
60. 请实现两个函数，分别用来序列化和反序列化二叉树。
61. 给定一颗二叉搜索树，请找出其中的第k大的结点。
62. 得到一个数据流中的中位数。
63. 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
64. 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
65. 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够达到多少个格子？
66. 输入一个链表，反转链表后，输出链表的所有元素。

### [Leetcode](https://github.com/fupengfei058/algorithm/tree/master/Leetcode)
1. Two Sum(Easy)
2. Add Two Numbers(Medium)
3. Longest Substring Without Repeating Characters(Medium)
4. Median of Two Sorted Arrays(Hard)
5. Longest Palindromic Substring(Medium)
6. ZigZag Conversion(Medium)
7. Reverse Integer(Easy)
8. String to Integer (atoi)(Medium)
9. Palindrome Number(Easy)
10. Regular Expression Matching(Hard)
11. Container With Most Water(Medium)
12. Integer to Roman(Medium)
13. Roman to Integer(Easy)
14. Longest Common Prefix(Easy)
15. 3Sum(Medium)
16. 3Sum Closest(Medium)
17. Letter Combinations of a Phone Number(Medium)
18. 4Sum(Medium)
19. Remove Nth Node From End of List(Medium)
20. Valid Parentheses(Easy)
21. Merge Two Sorted Lists(Easy)
22. Generate Parentheses(Medium)
23. Merge k Sorted Lists(Hard)
24. Swap Nodes in Pairs(Medium)
25. Reverse Nodes in k-Group(Hard)
26. Remove Duplicates from Sorted Array(Easy)
27. Remove Element(Easy)
28. Implement strStr()(Easy)
29. Divide Two Integers(Medium)
30. Substring with Concatenation of All Words(Hard)
31. Next Permutation(Medium)
32. Longest Valid Parentheses(Hard)
33. Search in Rotated Sorted Array(Medium)
34. Search for a Range(Medium)
35. Search Insert Position(Easy)
36. Valid Sudoku(Medium)
37. Sudoku Solver(Hard)
38. Count and Say(Easy)
39. Combination Sum(Medium)
40. Combination Sum II(Medium)
41. First Missing Positive(Hard)
42. Trapping Rain Water(Hard)
43. Multiply Strings(Medium)
44. Wildcard Matching(Hard)
45. Jump Game II(Hard)
46. Permutations(Medium)
47. Permutations II(Medium)
48. Rotate Image(Medium)
49. Group Anagrams(Medium)
50. Pow(x, n)(Medium)
51. N-Queens(Hard)
52. N-Queens II(Hard)
53. Maximum Subarray(Easy)
54. Spiral Matrix(Medium)
55. Jump Game(Medium)
56. Merge Intervals(Medium)
57. Insert Interval(Hard)
58. Length of Last Word(Easy)
59. Spiral Matrix II(Medium)
60. Permutation Sequence(Medium)
61. Rotate List(Medium)
62. Unique Paths(Medium)

### [经典题型](https://github.com/fupengfei058/algorithm/tree/master/%E7%BB%8F%E5%85%B8%E9%A2%98%E5%9E%8B)
1. 确定字符互异
2. 原串翻转
3. 确定两串乱序同构
4. 空格替换
5. 基本字符串压缩
6. 像素翻转
7. 压缩空格
8. 清除行列
9. 翻转子串
10. 求链表中倒数第k个数 
11. 访问单个节点的删除
12. 链表分割 
13. 链式A加B
14. 回文链表
15. 环形链表插值
16. 链表的k逆序
17. 复杂链表的复制
18. 链表判环
19. 无环单链表判相交
20. 集合栈
21. 用两个栈实现队列
22. 双栈排序
23. 猫狗收容所
24. 位运算_交换
25. 位运算_比较
26. 位运算_寻找奇数出现
27. 位运算_寻找奇数出现2
28. 位运算_二进制小数
29. 数学基础_加法运算替代
30. 动态规划_最大子段和问题
31. 动态规划_矩阵取值问题
32. 动态规划_最大和子矩阵
33. 动态规划_最长公共子序列
34. 动态规划_最长递增子序列
35. 动态规划_最小编辑代价
36. 字符串_全排列
37. 字符串_移位
38. 栈_下一个较大元素
39. 动态规划和递归_魔术索引
40. 数组_循环有序数组最小值
41. 数组_第一个缺失的整数
42. 数组_荷兰国旗问题
43. 数组_最大子数组和
44. 数组_最大间隔
45. 二叉树_遍历打印
46. 二叉树_根据前序和中序求中后序
47. 二叉树_层次遍历
48. 二叉树_二叉查找树判断
49. 二叉树_平衡二叉树判断
50. 二叉树_完全二叉树判断
51. 二叉树_树上最远距离
52. 二叉树_寻找错误结点
53. 二叉树_折纸问题
54. 二叉树_二叉树的镜像
55. 二叉树_树的子结构
56. 二叉树_二叉搜索树与双向链表
57. 二叉树_二叉搜索树的第k个结点
58. 查找和排序_数组中的逆序对
59. 查找和排序_查找和为定值的两个数
60. 查找和排序_最短子数组
61. 查找和排序_堆排序
62. 查找和排序_计数排序
63. 图_单词变换问题word-ladder
64. 栈的逆序
65. 数组_求最长可整合子数组的长度
66. 数组_未排序数组中累加和为给定值的最长子数组
67. 数组_最大子方阵
68. 数组_奇数位上都是奇数或者偶数位上都是偶数
69. 字符串_正则表达式匹配
70. 字符串_最短摘要生成算法
71. 数组_数组中出现次数超过一半的数字
72. 字符串_把一个数字看成字符串,判断是否为回文数
